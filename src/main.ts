import sdk, { DeviceBase, DeviceProvider, HttpRequest, HttpRequestHandler, HttpResponse, MediaObject, MixinProvider, Notifier, NotifierOptions, ObjectDetectionResult, ScryptedDevice, ScryptedDeviceBase, ScryptedDeviceType, ScryptedInterface, SecuritySystem, SecuritySystemMode, Setting, Settings, SettingValue, WritableDeviceState } from "@scrypted/sdk";
import { StorageSetting, StorageSettings, StorageSettingsDict } from "@scrypted/sdk/storage-settings";
import axios from "axios";
import child_process from 'child_process';
import { once } from "events";
import fs from 'fs';
import { cloneDeep, isEqual, keyBy, sortBy } from 'lodash';
import path from 'path';
import { BasePlugin, getBaseSettings, getMqttBasicClient } from '../../scrypted-apocaliss-base/src/basePlugin';
import { getRpcData } from '../../scrypted-monitor/src/utils';
import { name as pluginName, version } from '../package.json';
import { AiPlatform, getAiMessage } from "./aiUtils";
import { AdvancedNotifierCamera } from "./camera";
import { AdvancedNotifierCameraMixin } from "./cameraMixin";
import { DetectionClass, detectionClassesDefaultMap } from "./detecionClasses";
import { idPrefix, publishRuleEnabled, setupPluginAutodiscovery, subscribeToPluginMqttTopics } from "./mqtt-utils";
import { AdvancedNotifierNotifier } from "./notifier";
import { AdvancedNotifierNotifierMixin } from "./notifierMixin";
import { AdvancedNotifierSensorMixin } from "./sensorMixin";
import { ADVANCED_NOTIFIER_INTERFACE, AudioRule, BaseRule, convertSettingsToStorageSettings, DetectionRule, DetectionRuleActivation, deviceFilter, DeviceInterface, EventType, getAiSettings, getAllDevices, getDetectionRules, getDetectionRulesSettings, getElegibleDevices, getNowFriendlyDate, getPushoverPriority, getRuleKeys, getTextKey, getTextSettings, getWebooks, getWebookUrls, HOMEASSISTANT_PLUGIN_ID, LATEST_IMAGE_SUFFIX, NotificationPriority, NotificationSource, notifierFilter, nvrAcceleratedMotionSensorId, NvrEvent, OccupancyRule, ParseNotificationMessageResult, parseNvrNotificationMessage, pluginRulesGroup, PUSHOVER_PLUGIN_ID, RuleSource, RuleType, ruleTypeMetadataMap, ScryptedEventSource, SNAPSHOT_WIDTH, SnoozeAction, splitRules, StoreImageFn, supportedCameraInterfaces, supportedInterfaces, supportedSensorInterfaces, TimelapseRule } from "./utils";

const { systemManager, mediaManager } = sdk;
const defaultNotifierNativeId = 'advancedNotifierDefaultNotifier';
const cameraNativeId = 'advancedNotifierCamera';
const MAX_PENDING_RESULT_PER_CAMERA = 5;
const MAX_RPC_OBJECTS_PER_CAMERA = 50;

interface NotifyCameraProps {
    cameraDevice?: DeviceInterface,
    triggerDevice: DeviceInterface,
    notifierId: string,
    detectionKey: string,
    time: number,
    image?: MediaObject,
    detection?: ObjectDetectionResult
    textKey: string,
    rule?: DetectionRule,
    source?: NotificationSource,
    logger: Console,
    skipImage?: boolean,
}

export default class AdvancedNotifierPlugin extends BasePlugin implements MixinProvider, HttpRequestHandler, DeviceProvider {
    initStorage: StorageSettingsDict<string> = {
        ...getBaseSettings({
            onPluginSwitch: (_, enabled) => {
                this.startStop(enabled);
                this.startStopMixins(enabled);
            },
            hideHa: false,
            baseGroupName: ''
        }),
        pluginEnabled: {
            title: 'Plugin enabled',
            type: 'boolean',
            defaultValue: true,
            immediate: true,
        },
        mqttEnabled: {
            title: 'MQTT enabled',
            type: 'boolean',
            defaultValue: true,
            immediate: true,
        },
        debug: {
            title: 'Log debug messages',
            type: 'boolean',
            defaultValue: false,
            immediate: true,
        },
        sendDevNotifications: {
            title: 'Send notifications on config errors',
            description: 'Uses the devNotifier',
            type: 'boolean',
            defaultValue: false,
            immediate: true,
        },
        serverId: {
            title: 'Server identifier',
            type: 'string',
            hide: true,
        },
        localIp: {
            title: 'Server local ip',
            type: 'string',
            hide: true,
        },
        scryptedToken: {
            title: 'Scrypted token',
            description: 'Token to be found on the Homeassistant entity generated by the Scrypted integration (i.e. sensor.scrypted_token_{ip}',
            type: 'string',
        },
        nvrUrl: {
            title: 'NVR url',
            description: 'Url pointing to the NVR instance, useful to generate direct links to timeline',
            type: 'string',
            defaultValue: 'https://nvr.scrypted.app/',
            placeholder: 'https://nvr.scrypted.app/',
        },
        enableCameraDevice: {
            title: 'Enable Camera',
            description: 'Enable a camera device allowing to replay past timelapses generated',
            type: 'boolean',
            immediate: true,
            onPut: async (_, active) => this.executeCameraDiscovery(active)
        },
        domains: {
            subgroup: 'Homeassistant',
            title: 'Entity regex patterns',
            description: 'Regex to filter out entities fetched',
            type: 'string',
            multiple: true,
            defaultValue: ['binary_sensor.(.*)_triggered'],
        },
        fetchHaEntities: {
            subgroup: 'Homeassistant',
            title: 'Fetch entities from HA',
            type: 'button',
            onPut: async () => await this.fetchHomeassistantData()
        },
        mqttActiveEntitiesTopic: {
            title: 'Active entities topic',
            subgroup: 'MQTT',
            description: 'Topic containing the active entities, will trigger the related devices activation for notifications',
            onPut: async () => {
                await this.setupMqttEntities();
            },
        },
        useNvrDetectionsForMqtt: {
            subgroup: 'MQTT',
            title: 'Use NVR detections',
            description: 'Use NVR detection to publish MQTT state messages for basic detections.',
            type: 'boolean',
            immediate: true
        },
        ...getTextSettings(false),
        [ruleTypeMetadataMap[RuleType.Detection].rulesKey]: {
            title: 'Detection rules',
            group: pluginRulesGroup,
            type: 'string',
            multiple: true,
            combobox: true,
            choices: [],
            defaultValue: [],
            onPut: async () => await this.refreshSettings()
        },
        activeDevicesForNotifications: {
            title: '"OnActive" devices',
            group: pluginRulesGroup,
            type: 'device',
            multiple: true,
            combobox: true,
            deviceFilter: deviceFilter,
            defaultValue: [],
        },
        objectDetectionDevice: {
            title: 'Object Detector',
            group: pluginRulesGroup,
            description: 'Select the object detection plugin to use for detecting objects.',
            type: 'device',
            deviceFilter: `interfaces.includes('ObjectDetectionPreview') && id !== '${nvrAcceleratedMotionSensorId}'`,
            immediate: true,
        },
        securitySystem: {
            title: 'Security system',
            group: pluginRulesGroup,
            description: 'Select the security system device that will be used to enable rules.',
            type: 'device',
            deviceFilter: `type === '${ScryptedDeviceType.SecuritySystem}'`,
            immediate: true,
        },
        testDevice: {
            title: 'Device',
            group: 'Test',
            immediate: true,
            type: 'device',
            deviceFilter: deviceFilter,
        },
        testNotifier: {
            group: 'Test',
            title: 'Notifier',
            type: 'device',
            deviceFilter: notifierFilter,
            immediate: true,
        },
        testMessage: {
            group: 'Test',
            title: 'Message key',
            type: 'string',
            immediate: true,
            choices: Object.keys(getTextSettings(false)).map(key => key)
        },
        testPriority: {
            group: 'Test',
            title: 'Pushover priority',
            type: 'string',
            immediate: true,
            choices: [NotificationPriority.VeryLow, NotificationPriority.Low, NotificationPriority.Normal, NotificationPriority.High],
            defaultValue: NotificationPriority.Normal
        },
        testUseAi: {
            group: 'Test',
            title: 'Use AI for descriptions',
            type: 'boolean',
            immediate: true,
            defaultValue: false
        },
        testButton: {
            group: 'Test',
            title: 'Send notification',
            type: 'button',
            onPut: async () => {
                await this.executeNotificationTest();
            },
        },
        checkConfigurations: {
            group: 'Test',
            title: 'Check configurations',
            type: 'button',
            onPut: async () => {
                await this.checkPluginConfigurations(true);
            },
        },
        aiPlatform: {
            title: 'AI Platform',
            type: 'string',
            group: 'AI',
            immediate: true,
            choices: Object.values(AiPlatform),
            defaultValue: AiPlatform.Disabled,
            onPut: async () => await this.refreshSettings()
        },
        imagesPath: {
            title: 'Storage path',
            group: 'Storage',
            description: 'Disk path where to save images. Leave blank if you do not want any image to be stored',
            type: 'string',
        },
        imagesRegex: {
            title: 'Images name',
            description: 'Filename for the images. Possible values to be used are: ${name} ${timestamp}. Using only ${name} will ensure to have only 1 image per file',
            group: 'Storage',
            type: 'string',
            defaultValue: '${name}',
            placeholder: '${name}',
        },
        cleanup340: {
            type: 'boolean',
            hide: true,
        },
    };
    storageSettings = new StorageSettings(this, this.initStorage);

    private deviceHaEntityMap: Record<string, string> = {};
    private haEntityDeviceMap: Record<string, string> = {};
    private deviceVideocameraMap: Record<string, string> = {};
    private videocameraDevicesMap: Record<string, string[]> = {};
    public deviceRoomMap: Record<string, string> = {}
    private doorbellDevices: string[] = [];
    public currentCameraMixinsMap: Record<string, AdvancedNotifierCameraMixin> = {};
    public currentSensorMixinsMap: Record<string, AdvancedNotifierSensorMixin> = {};
    public currentNotifierMixinsMap: Record<string, AdvancedNotifierNotifierMixin> = {};
    private mainFlowInterval: NodeJS.Timeout;
    defaultNotifier: AdvancedNotifierNotifier;
    camera: AdvancedNotifierCamera;
    runningDetectionRules: DetectionRule[] = [];
    lastNotExistingNotifier: number;
    allAvailableRules: BaseRule[] = [];
    fetchedEntities: string[] = [];
    lastAutoDiscovery: number;
    hasCloudPlugin: boolean;

    constructor(nativeId: string) {
        super(nativeId, {
            pluginFriendlyName: 'Advanced notifier'
        });

        const logger = this.getLogger();

        const cloudPlugin = systemManager.getDeviceByName('Scrypted Cloud') as unknown as Settings;
        if (cloudPlugin) {
            this.hasCloudPlugin = true;
        } else {
            logger.log('Cloud plugin not found');
            this.hasCloudPlugin = false;
        }

        const [major, minor, patch] = version.split('.').map(num => parseInt(num, 10));

        if (major === 3 && minor === 4 && !this.storageSettings.values.cleanup340) {
            (async () => {
                const basePath = process.env.SCRYPTED_PLUGIN_VOLUME;
                const snapshotsFolder = path.join(basePath, 'snapshots');

                fs.promises.rm(snapshotsFolder, { force: true, recursive: true })
                    .then(() => {
                        logger.log('Old snapshots folder cleaned up');
                        this.storageSettings.values.cleanup340 = true;
                    })
                    .catch(logger.log);
            })();
        }

        (async () => {
            await sdk.deviceManager.onDeviceDiscovered(
                {
                    name: 'Advanced notifier NVR notifier',
                    nativeId: defaultNotifierNativeId,
                    interfaces: [ScryptedInterface.Notifier],
                    type: ScryptedDeviceType.Notifier,
                },
            );

            await this.executeCameraDiscovery(this.storageSettings.values.enableCameraDevice);
        })();

        this.startStop(this.storageSettings.values.pluginEnabled).then().catch(this.getLogger().log);
    }

    async executeCameraDiscovery(active: boolean) {
        const interfaces: ScryptedInterface[] = [ScryptedInterface.Camera, ScryptedInterface.VideoClips];
        if (active) {
            interfaces.push(ScryptedInterface.VideoCamera);
        }

        await sdk.deviceManager.onDeviceDiscovered(
            {
                name: 'Advanced notifier Camera',
                nativeId: cameraNativeId,
                interfaces,
                type: ScryptedDeviceType.Camera,
            }
        );
    }

    async getDevice(nativeId: string) {
        if (nativeId === defaultNotifierNativeId)
            return this.defaultNotifier ||= new AdvancedNotifierNotifier(defaultNotifierNativeId, this);
        if (nativeId === cameraNativeId)
            return this.camera ||= new AdvancedNotifierCamera(cameraNativeId, this);
    }

    async releaseDevice(id: string, nativeId: string): Promise<void> {
    }

    async startStop(enabled: boolean) {
        if (enabled) {
            await this.start();
        } else {
            await this.stop();
        }
    }

    async stop() {
        this.mainFlowInterval && clearInterval(this.mainFlowInterval);
        await this.mqttClient?.disconnect();
    }

    async startStopMixins(enabled: boolean) {
        for (const mixin of Object.values(this.currentCameraMixinsMap)) {
            await mixin.startStop(enabled);
        }
        for (const mixin of Object.values(this.currentSensorMixinsMap)) {
            await mixin.startStop(enabled);
        }
    }

    async start() {
        try {
            await this.refreshSettings();
            await this.initPluginSettings();
            await this.mainFlow();

            this.mainFlowInterval = setInterval(async () => {
                await this.mainFlow();

                const now = Date.now();
                if (!this.lastAutoDiscovery || (now - this.lastAutoDiscovery) > 1000 * 60 * 60) {
                    this.lastAutoDiscovery = now;

                    await this.checkPluginConfigurations(false);
                    await this.sendAutoDiscovery();
                }
            }, 2 * 1000);
        } catch (e) {
            this.getLogger().log(`Error in initFlow`, e);
        }
    }

    async onRequest(request: HttpRequest, response: HttpResponse): Promise<void> {
        const logger = this.getLogger();
        const url = new URL(`http://localhost${request.url}`);
        const params = url.searchParams.get('params') ?? '{}';

        const { filename } = JSON.parse(params);
        const [_, __, ___, ____, _____, webhook, ...rest] = url.pathname.split('/');
        const [deviceIdOrActionRaw, ruleNameOrSnoozeIdOrSnapshotId, timelapseNameOrSnoozeTime] = rest
        const deviceIdOrAction = decodeURIComponent(deviceIdOrActionRaw);
        logger.info(`Webhook request: ${JSON.stringify({
            url: request.url,
            webhook,
            deviceIdOrActionRaw,
            deviceIdOrAction,
            ruleNameOrSnoozeIdOrSnapshotId,
            timelapseNameOrSnoozeTime,
        })}`);

        try {
            const { lastSnapshot, haAction, timelapseDownload, timelapseStream, timelapseThumbnail, snoozeNotification } = await getWebooks();
            if (webhook === haAction) {
                const { url, accessToken } = await this.getHaApiUrl();

                await axios.post(`${url}/api/events/mobile_app_notification_action`,
                    { "action": deviceIdOrAction },
                    {
                        headers: {
                            'Authorization': 'Bearer ' + accessToken,
                        }
                    });

                response.send(`Action ${deviceIdOrAction} executed`, {
                    code: 200,
                });
                return;
            } else if (webhook === lastSnapshot) {
                const device = this.currentCameraMixinsMap[deviceIdOrAction];
                const isWebhookEnabled = device?.storageSettings.values.lastSnapshotWebhook;

                if (isWebhookEnabled) {
                    const realDevice = systemManager.getDeviceById<ScryptedDeviceBase>(device.id);

                    const imageIdentifier = `${ruleNameOrSnoozeIdOrSnapshotId}${LATEST_IMAGE_SUFFIX}`;
                    const { filePath: imagePath } = this.getImagePath({ device: realDevice, imageIdentifier });

                    try {
                        const mo = await sdk.mediaManager.createFFmpegMediaObject({
                            inputArguments: [
                                '-i', imagePath,
                            ]
                        });
                        const jpeg = await sdk.mediaManager.convertMediaObjectToBuffer(mo, 'image/jpeg');
                        response.send(jpeg, {
                            headers: {
                                'Content-Type': 'image/jpeg',
                            }
                        });
                        return;
                    } catch (e) {
                        const message = `Error getting snapshot ${ruleNameOrSnoozeIdOrSnapshotId} for device ${device.name}`;
                        logger.log(message)
                        response.send(message, {
                            code: 404,
                        });
                        return;
                    }
                }
            } else if (webhook === timelapseDownload) {
                const decodedTimelapseName = decodeURIComponent(timelapseNameOrSnoozeTime);
                const decodedRuleName = decodeURIComponent(ruleNameOrSnoozeIdOrSnapshotId);
                const { generatedPath } = this.getTimelapseFolder({
                    ruleName: decodedRuleName
                });

                const timelapsePath = path.join(generatedPath, decodedTimelapseName);
                logger.debug(`Requesting timelapse ${decodedRuleName} for download: ${JSON.stringify({
                    generatedPath,
                    timelapseName: timelapseNameOrSnoozeTime,
                    decodedTimelapseName,
                    ruleName: ruleNameOrSnoozeIdOrSnapshotId,
                    decodedRuleName,
                    timelapsePath,
                })}`);

                response.sendFile(timelapsePath);
                return;
            } else if (webhook === timelapseStream) {
                const stat = await fs.promises.stat(filename);
                const fileSize = stat.size;
                const range = request.headers.range;

                logger.debug(`Videoclip requested: ${JSON.stringify({
                    filename,
                })}`);

                if (range) {
                    const parts = range.replace(/bytes=/, "").split("-");
                    const start = parseInt(parts[0], 10);
                    const end = parts[1] ? parseInt(parts[1], 10) : fileSize - 1;

                    const chunksize = (end - start) + 1;
                    const file = fs.createReadStream(filename, { start, end });

                    const sendVideo = async () => {
                        return new Promise<void>((resolve, reject) => {
                            try {
                                response.sendStream((async function* () {
                                    for await (const chunk of file) {
                                        yield chunk;
                                    }
                                })(), {
                                    code: 206,
                                    headers: {
                                        'Content-Range': `bytes ${start}-${end}/${fileSize}`,
                                        'Accept-Ranges': 'bytes',
                                        'Content-Length': chunksize,
                                        'Content-Type': 'video/mp4',
                                    }
                                });

                                resolve();
                            } catch (err) {
                                reject(err);
                            }
                        });
                    };

                    try {
                        await sendVideo();
                        return;
                    } catch (e) {
                        logger.log('Error fetching videoclip', e);
                    }
                } else {
                    response.sendFile(filename, {
                        code: 200,
                        headers: {
                            'Content-Length': fileSize,
                            'Content-Type': 'video/mp4',
                        }
                    });
                }

                return;
            } else if (webhook === timelapseThumbnail) {
                const thumbnailMo = await this.camera.getVideoClipThumbnail(decodeURIComponent(filename));
                if (!thumbnailMo) {
                    response.send('Generating', {
                        code: 400
                    });
                    return;
                }
                const jpeg = await sdk.mediaManager.convertMediaObjectToBuffer(thumbnailMo, 'image/jpeg');
                response.send(jpeg, {
                    headers: {
                        'Content-Type': 'image/jpeg',
                    }
                });
            } else if (webhook === snoozeNotification) {
                const decodedSnoozeTime = decodeURIComponent(timelapseNameOrSnoozeTime);
                const decodedSnoozeId = decodeURIComponent(ruleNameOrSnoozeIdOrSnapshotId);
                const device = this.currentCameraMixinsMap[deviceIdOrAction];

                const message = `Snoozing notifications ${decodedSnoozeId} for device ${device?.name} for ${decodedSnoozeTime} seconds`;
                logger.log(message);

                device?.snoozeNotification({
                    detectionKey: decodedSnoozeId,
                    snoozeTime: Number(decodedSnoozeTime)
                });

                response.send(message, {
                    code: 200,
                });
            }
        } catch (e) {
            response.send(`${JSON.stringify(e)}, ${e.message}`, {
                code: 400,
            });

            return;
        }

        response.send(`Webhook not found`, {
            code: 404,
        });

        return;
    }

    private async sendAutoDiscovery() {
        if (this.storageSettings.values.mqttEnabled) {
            const mqttClient = await this.getMqttClient();
            const logger = this.getLogger();
            const objDetectionPlugin = systemManager.getDeviceByName('Scrypted NVR Object Detection') as unknown as Settings;
            const settings = await objDetectionPlugin.getSettings();
            const knownPeople = settings?.find(setting => setting.key === 'knownPeople')?.choices
                ?.filter(choice => !!choice)
                .map(person => person.trim());

            const pluginStorage = this.storageSettings;
            const { availableRules } = getDetectionRules({ pluginStorage, console: logger });

            logger.log('Starting MQTT autodiscovery');
            setupPluginAutodiscovery({
                mqttClient,
                people: knownPeople,
                console: logger,
                rules: availableRules,
            }).then(async (activeTopics) => {
                await this.mqttClient.cleanupAutodiscoveryTopics(activeTopics);
            }).catch(logger.error);

            this.allAvailableRules = availableRules;

            await this.setupMqttEntities();
        }
    }

    async putSetting(key: string, value: SettingValue): Promise<void> {
        return this.storageSettings.putSetting(key, value);
    }

    async getMqttClient() {
        if (!this.mqttClient && !this.initializingMqtt) {
            const { mqttEnabled, useMqttPluginCredentials, pluginEnabled, mqttHost, mqttUsename, mqttPassword } = this.storageSettings.values;
            if (mqttEnabled && pluginEnabled) {
                this.initializingMqtt = true;
                const logger = this.getLogger();

                if (this.mqttClient) {
                    this.mqttClient.disconnect();
                    this.mqttClient = undefined;
                }

                try {
                    this.mqttClient = await getMqttBasicClient({
                        logger,
                        useMqttPluginCredentials,
                        mqttHost,
                        mqttUsename,
                        mqttPassword,
                        clientId: `scrypted_an`,
                        configTopicPattern: `homeassistant/+/${idPrefix}-${this.pluginId}/+/config`
                    });
                    await this.mqttClient?.getMqttClient();
                } catch (e) {
                    logger.log('Error setting up MQTT client', e);
                } finally {
                    this.initializingMqtt = false;
                }
            }
        }

        return this.mqttClient;
    }

    getLogger(device?: ScryptedDeviceBase) {
        let logger = super.getLogger();
        if (device) {
            logger = this.currentCameraMixinsMap[device.id]?.getLogger() ??
                this.currentSensorMixinsMap[device.id]?.getLogger() ?? logger;
        }

        return logger;
    }

    private async setupMqttEntities() {
        const { mqttEnabled, mqttActiveEntitiesTopic } = this.storageSettings.values;
        if (mqttEnabled) {
            try {
                const mqttClient = await this.getMqttClient();
                const logger = this.getLogger();

                this.getLogger().log(`Subscribing to mqtt topics`);
                await subscribeToPluginMqttTopics({
                    entitiesActiveTopic: mqttActiveEntitiesTopic,
                    mqttClient,
                    console: logger,
                    rules: this.allAvailableRules,
                    activeEntitiesCb: async (message) => {
                        logger.debug(`Received update for ${mqttActiveEntitiesTopic} topic: ${JSON.stringify(message)}`);
                        await this.syncHaEntityIds(message);
                    },
                    activationRuleCb: async ({ active, ruleName }) => {
                        const { common: { enabledKey } } = getRuleKeys({ ruleName, ruleType: RuleType.Detection });
                        logger.debug(`Setting rule ${ruleName} to ${active}`);
                        await this.putSetting(enabledKey, active);
                    },
                });
            } catch (e) {
                this.getLogger().log('Error setting up MQTT client', e);
            }
        }
    }

    private async syncHaEntityIds(devices: string[]) {
        const logger = this.getLogger();
        const deviceIds: string[] = [];
        for (const device of devices) {
            const deviceNameFromEntity = this.haEntityDeviceMap[device];
            const entityFromDeviceName = this.deviceHaEntityMap[device];

            if (deviceNameFromEntity) {
                deviceIds.push(deviceNameFromEntity);
            } else if (entityFromDeviceName) {
                deviceIds.push(device);
            }
        }

        logger.debug(`SyncHaEntityIds: ${JSON.stringify({
            devices,
            stored: this.storageSettings.values.activeDevicesForNotifications ?? [],
            isEqual: isEqual(sortBy(deviceIds), sortBy(this.storageSettings.values.activeDevicesForNotifications ?? []))
        })}`);

        if (isEqual(sortBy(deviceIds), sortBy(this.storageSettings.values.activeDevicesForNotifications ?? []))) {
            logger.debug('Devices did not change');
        } else {
            logger.log(`"OnActiveDevices" changed: ${JSON.stringify(deviceIds)}`);
            this.putSetting('activeDevicesForNotifications', deviceIds);
        }
    }

    private async initPluginSettings() {
        const logger = this.getLogger();
        if (this.hasCloudPlugin) {
            const cloudPlugin = systemManager.getDeviceByName('Scrypted Cloud') as unknown as Settings;
            const oauthUrl = await (cloudPlugin as any).getOauthUrl();
            const url = new URL(oauthUrl);
            const serverId = url.searchParams.get('server_id');
            this.putSetting('serverId', serverId);
            logger.log(`Server id found: ${serverId}`);
        }

        const localIp = (await sdk.endpointManager.getLocalAddresses())?.[0];
        this.putSetting('localIp', localIp);
        logger.log(`Local IP found: ${localIp}`);

        if (this.storageSettings.values.haEnabled) {
            await this.fetchHomeassistantData();
        }
    }

    private async mainFlow() {
        const logger = this.getLogger();
        try {
            const doorbellDevices: string[] = [];
            const haEntities: string[] = [];
            const deviceHaEntityMap: Record<string, string> = {};
            const haEntityDeviceMap: Record<string, string> = {};
            const deviceVideocameraMap: Record<string, string> = {};
            const videocameraDevicesMap: Record<string, string[]> = {};
            const deviceRoomMap: Record<string, string> = {};

            const allDevices = getElegibleDevices();
            for (const device of allDevices) {
                const deviceId = device.id;
                const deviceType = device.type;
                try {
                    const settings = await device.getSettings();
                    const haEntityId = settings.find(setting => setting.key === 'homeassistantMetadata:entityId')?.value as string;
                    const linkedCamera = settings.find(setting => setting.key === 'homeassistantMetadata:linkedCamera')?.value as string;
                    const nearbySensors = (settings.find(setting => setting.key === 'recording:nearbySensors')?.value as string[]) ?? [];
                    const nearbyLocks = (settings.find(setting => setting.key === 'recording:nearbyLocks')?.value as string[]) ?? [];

                    deviceRoomMap[deviceId] = device.room;
                    if (haEntityId) {
                        haEntities.push(haEntityId);

                        deviceHaEntityMap[deviceId] = haEntityId;
                        haEntityDeviceMap[haEntityId] = deviceId;
                    }

                    if (deviceType === ScryptedDeviceType.Doorbell) {
                        const doorbellButtonId = settings.find(setting => setting.key === 'replaceBinarySensor:replaceBinarySensor')?.value as string;
                        if (doorbellButtonId) {
                            doorbellDevices.push(doorbellButtonId);
                            deviceVideocameraMap[doorbellButtonId] = deviceId;
                        }
                    }

                    if (linkedCamera) {
                        const cameraDevice = systemManager.getDeviceById(linkedCamera);
                        if (cameraDevice) {
                            const cameraId = cameraDevice.id;
                            deviceVideocameraMap[deviceId] = cameraId;
                            if (!videocameraDevicesMap[cameraId]) {
                                videocameraDevicesMap[cameraId] = [];
                            }
                            !videocameraDevicesMap[cameraId].includes(deviceId) && videocameraDevicesMap[cameraId].push(deviceId);
                        } else {
                            logger.log(`Device ${device.name} is linked to the cameraId ${linkedCamera}, not available anymore`);
                        }
                    }

                    if ([ScryptedDeviceType.Doorbell, ScryptedDeviceType.Camera].includes(deviceType)) {
                        const allLinkedSensorIds = [...nearbySensors, ...nearbyLocks];

                        for (const linkedSensorId of allLinkedSensorIds) {
                            deviceVideocameraMap[linkedSensorId] = deviceId;
                            if (!videocameraDevicesMap[deviceId]) {
                                videocameraDevicesMap[deviceId] = [];
                            }
                            !videocameraDevicesMap[deviceId].includes(linkedSensorId) && videocameraDevicesMap[deviceId].push(linkedSensorId);
                        }
                    }
                } catch (e) {
                    logger.log(`Error in mainFlow-${device}`, e);
                }
            }

            const pluginStorage = this.storageSettings;
            const { availableRules, allowedRules } = getDetectionRules({ pluginStorage, console: logger });

            const [rulesToEnable, rulesToDisable] = splitRules({
                allRules: availableRules,
                currentlyRunningRules: this.runningDetectionRules,
                rulesToActivate: allowedRules
            });

            for (const rule of rulesToEnable) {
                logger.log(`${rule.ruleType} rule started: ${rule.name}`);
                const { common: { currentlyActiveKey } } = getRuleKeys({ ruleName: rule.name, ruleType: rule.ruleType });
                this.putSetting(currentlyActiveKey, 'true');
            }

            for (const rule of rulesToDisable) {
                logger.log(`${rule.ruleType} rule stopped: ${rule.name}`);
                const { common: { currentlyActiveKey } } = getRuleKeys({ ruleName: rule.name, ruleType: rule.ruleType });
                this.putSetting(currentlyActiveKey, 'false');
            }

            this.runningDetectionRules = cloneDeep(allowedRules) || [];
            this.deviceHaEntityMap = deviceHaEntityMap;
            this.haEntityDeviceMap = haEntityDeviceMap;
            this.deviceVideocameraMap = deviceVideocameraMap;
            this.videocameraDevicesMap = videocameraDevicesMap;
            this.deviceRoomMap = deviceRoomMap;
            this.doorbellDevices = doorbellDevices;

            const activeDevices = (getAllDevices().filter(device => device.interfaces.includes(ADVANCED_NOTIFIER_INTERFACE))?.length || 0) + 1;

            if (!!activeDevices) {
                const { pendingResults, rpcObjects } = await getRpcData();
                const pluginPendingResults = pendingResults.find(elem => elem.name === pluginName)?.count;
                const pluginRpcObjects = rpcObjects.find(elem => elem.name === pluginName)?.count;
                logger.info(`PLUGIN-STUCK-CHECK: active devices ${activeDevices}, pending resutls ${pluginPendingResults} RPC objects ${pluginRpcObjects}`);

                if (
                    pluginPendingResults > (MAX_PENDING_RESULT_PER_CAMERA * activeDevices) ||
                    pluginRpcObjects > (MAX_RPC_OBJECTS_PER_CAMERA * activeDevices)
                ) {
                    logger.error(`Plugin seems stuck, ${pluginPendingResults} pending results and ${pluginRpcObjects} RPC objects. Restarting`);
                    await sdk.deviceManager.requestRestart();
                }

                logger.info('RPC data', pluginPendingResults, pluginRpcObjects);
            }
        } catch (e) {
            logger.log('Error in mainFlow', e);
        }
    }

    private async checkPluginConfigurations(manual: boolean) {
        const logger = this.getLogger();
        try {
            const notifiersRegex = new RegExp('(rule|occupancyRule|timelapseRule):(.*):notifiers');
            const devicesRegex = new RegExp('(rule|occupancyRule|timelapseRule):(.*):devices');
            const activationTypeRegex = new RegExp('rule:(.*):activation');
            const allDevices = getElegibleDevices();

            const missingNotifiersOfDeviceRules: { deviceName: string, ruleName: string, notifierIds: string[] }[] = [];
            const missingNotifiersOfPluginRules: { ruleName: string, notifierIds: string[] }[] = [];
            const missingDevicesOfPluginRules: { ruleName: string, deviceIds: string[] }[] = [];
            const devicesWithoutRoom: string[] = [];

            for (const device of allDevices) {
                if (!device.room) {
                    devicesWithoutRoom.push(device.name);
                }

                const mixin = this.currentCameraMixinsMap[device.id] || this.currentSensorMixinsMap[device.id];

                const notifiersSettings = (await mixin.storageSettings.getSettings())
                    .filter((sett) => sett.key?.match(notifiersRegex));

                for (const notifiersSetting of notifiersSettings) {
                    const [_, type, name] = notifiersSetting.key.match(notifiersRegex);
                    const missingNotifiers = (notifiersSetting.value as string[])?.filter(notifierId => !sdk.systemManager.getDeviceById(notifierId));
                    if (missingNotifiers.length) {
                        missingNotifiersOfDeviceRules.push({ deviceName: device.name, notifierIds: missingNotifiers, ruleName: `${type}_${name}` });
                    }
                }
            }

            const pluginStorage = this.storageSettings;
            const notifiersSettings = (await this.storageSettings.getSettings())
                .filter((sett) => sett.key?.match(notifiersRegex));

            for (const notifiersSetting of notifiersSettings) {
                const [_, type, name] = notifiersSetting.key.match(notifiersRegex);
                const missingNotifiers = (notifiersSetting.value as string[])?.filter(notifierId => !sdk.systemManager.getDeviceById(notifierId));
                if (missingNotifiers.length) {
                    missingNotifiersOfPluginRules.push({ notifierIds: missingNotifiers, ruleName: `${type}_${name}` });
                }
            }

            const devicesSettings = (await this.storageSettings.getSettings())
                .filter((sett) => sett.key?.match(devicesRegex));

            for (const devicesSetting of devicesSettings) {
                const [_, type, name] = devicesSetting.key.match(devicesRegex);
                const missingDevices = (devicesSetting.value as string[])?.filter(deviceId => !sdk.systemManager.getDeviceById(deviceId));
                if (missingDevices.length) {
                    missingDevicesOfPluginRules.push({ deviceIds: missingDevices, ruleName: `${type}_${name}` });
                }
            }

            const anyActiveOnRules = Object.entries(pluginStorage)
                .filter(([key, setting]) => key?.match(activationTypeRegex) && setting.value === DetectionRuleActivation.OnActive);

            const sensorsNotLinkedToAnyCamera = allDevices.filter(
                device => device.type === ScryptedDeviceType.Sensor && !this.deviceVideocameraMap[device.id]
            ).map(sensor => sensor.name);

            const entitiesWithWrongEntityId = allDevices.filter(
                device => !this.deviceHaEntityMap[device.id] || !this.fetchedEntities.includes(this.deviceHaEntityMap[device.id])
            ).map(sensor => sensor.name);

            const {
                devNotifier,
                sendDevNotifications,
                imagesPath,
                scryptedToken,
                nvrUrl,
                objectDetectionDevice,
                haEnabled,
                securitySystem,
            } = this.storageSettings.values;
            let storagePathError;

            const imagesPathSet = imagesPath && imagesPath !== '';

            if (imagesPathSet) {
                try {
                    await fs.promises.access(imagesPath);
                } catch (e) {
                    storagePathError = e;
                }
            }

            const alertHaIssues = haEnabled && anyActiveOnRules;

            const securitySystemDevice: SecuritySystem = typeof securitySystem === 'string' ? sdk.systemManager.getDeviceById<SecuritySystem>(securitySystem) : securitySystem;
            const securitySyetemState = securitySystemDevice?.securitySystemState;
            const securitySystemCorrectMode = securitySyetemState ? Object.keys(SecuritySystemMode).includes(securitySyetemState.mode) : undefined;

            const body = JSON.stringify({
                missingNotifiersOfDeviceRules: missingNotifiersOfDeviceRules.length ? missingNotifiersOfDeviceRules : undefined,
                missingNotifiersOfPluginRules: missingNotifiersOfPluginRules.length ? missingNotifiersOfPluginRules : undefined,
                missingDevicesOfPluginRules: missingDevicesOfPluginRules.length ? missingDevicesOfPluginRules : undefined,
                sensorsNotLinkedToAnyCamera: sensorsNotLinkedToAnyCamera.length ? sensorsNotLinkedToAnyCamera : undefined,
                entitiesWithWrongEntityId: entitiesWithWrongEntityId.length ? entitiesWithWrongEntityId : undefined,
                devicesWithoutRoom: devicesWithoutRoom.length ? devicesWithoutRoom : undefined,
                storagePathError: storagePathError ?? (imagesPathSet ? 'No error' : 'Not set'),
                scryptedToken: scryptedToken ? 'Set' : 'Not set',
                serverId: this.storageSettings.getItem('serverId') ? 'Found' : 'Not found',
                nvrUrl: nvrUrl ? 'Set' : 'Not set',
                objectDetectionDevice: objectDetectionDevice ? objectDetectionDevice.name : 'Not set',
                securitySystemSet: securitySystemDevice ? 'Set' : 'Not set',
                securitySystemState: securitySystemDevice ? securitySystemCorrectMode ? 'Ok' : `Wrong: ${securitySyetemState?.mode}` : undefined
            });

            if (manual) {
                logger.log(`checkPluginConfigurations results: ${body}`);
            } else {
                logger.debug(`Results: ${body}`);

                if (
                    missingNotifiersOfDeviceRules.length ||
                    missingNotifiersOfPluginRules.length ||
                    missingDevicesOfPluginRules.length ||
                    sensorsNotLinkedToAnyCamera.length ||
                    (alertHaIssues && devicesWithoutRoom.length) ||
                    (alertHaIssues && entitiesWithWrongEntityId.length) ||
                    !!storagePathError
                ) {
                    sendDevNotifications && (devNotifier as Notifier).sendNotification('Advanced notifier not correctly configured', {
                        body
                    });
                }
            }
        } catch (e) {
            logger.log('Error in checkExistingDevices', e);
        }
    }

    async toggleRule(ruleName: string, ruleType: RuleType, enabled: boolean) {
        const mqttClient = await this.getMqttClient();
        const logger = this.getLogger();
        const rule = this.allAvailableRules.find(rule => rule.ruleType === ruleType && rule.name === ruleName);

        logger.log(`Setting ${ruleType} rule ${ruleName} enabled to ${enabled}`);

        if (rule) {
            await publishRuleEnabled({
                console: logger,
                rule,
                enabled,
                mqttClient
            });
        }
    };

    async refreshSettings() {
        const logger = this.getLogger();
        const dynamicSettings: StorageSetting[] = [];

        const detectionRulesSettings = await getDetectionRulesSettings({
            storage: this.storageSettings,
            ruleSource: RuleSource.Plugin,
            logger,
            onShowMore: async () => await this.refreshSettings(),
            onRuleToggle: async (ruleName: string, enabled: boolean) => this.toggleRule(ruleName, RuleType.Detection, enabled),
        });

        dynamicSettings.push(...getAiSettings({
            aiPlatform: this.storageSettings.values.aiPlatform,
            logger,
            onRefresh: async () => await this.refreshSettings(),
        }));

        dynamicSettings.push(...detectionRulesSettings);

        this.storageSettings = await convertSettingsToStorageSettings({
            device: this,
            dynamicSettings,
            initStorage: this.initStorage
        });
    }

    async getSettings() {
        try {
            const { haEnabled } = this.storageSettings.values;
            this.storageSettings.settings.domains.hide = !haEnabled;
            this.storageSettings.settings.fetchHaEntities.hide = !haEnabled;

            return super.getSettings();
        } catch (e) {
            this.getLogger().log('Error in getSettings', e);
            return [];
        }
    }

    fetchHomeassistantData = async () => {
        const { domains } = this.storageSettings.values;
        const logger = this.getLogger();

        let entityIds: string[] = [];

        try {
            logger.log(`Fetching homeassistant data`);
            const haApi = await this.getHaApi();
            const entitiesResponse = await haApi.getStatesData();

            entityIds = sortBy(
                entitiesResponse.data
                    .filter(entityStatus => domains.length > 0 ? domains.some(domain => new RegExp(domain).test(entityStatus.entity_id)) : true),
                elem => elem.entity_id)
                .map(entityStatus => entityStatus.entity_id);
        } catch (e) {
            logger.log(e);
        } finally {
            logger.debug(`Entities found: ${JSON.stringify(entityIds)}`);
            this.fetchedEntities = entityIds;

            logger.log(`HA data fetched`);
        }
    }

    async canMixin(type: ScryptedDeviceType, interfaces: string[]): Promise<string[]> {
        if (
            supportedInterfaces.some(int => interfaces.includes(int))
        ) {
            return [ScryptedInterface.Settings, ADVANCED_NOTIFIER_INTERFACE]
        }

        return undefined;
    }

    async notifyOccupancyEvent(props: {
        cameraDevice: DeviceInterface,
        triggerTime: number,
        message: string,
        rule: OccupancyRule,
        image: MediaObject,
    }) {
        const { cameraDevice, rule, message, triggerTime, image } = props;
        const logger = this.getLogger(cameraDevice);

        for (const notifierId of rule.notifiers) {
            const notifier = systemManager.getDeviceById<ScryptedDevice & Notifier & DeviceBase & Settings>(notifierId);

            const { data } = await this.getNotifierData({
                device: cameraDevice,
                notifier,
                triggerTime,
                rule,
            });

            const notifierOptions: NotifierOptions = {
                body: message,
                data
            }

            const title = cameraDevice.name;

            logger.log(`Sending Occupancy event notification ${triggerTime} to ${notifier.name}`);
            logger.info(`${JSON.stringify({
                notifierOptions,
                title,
                message,
            })}`)

            await this.sendNotificationInternal({
                logger,
                notifier,
                title,
                icon: undefined,
                image,
                notifierOptions
            });
        }
    }

    async notifyAudioEvent(props: {
        cameraDevice: DeviceInterface,
        triggerTime: number,
        message: string,
        rule: AudioRule,
        image: MediaObject,
    }) {
        const { cameraDevice, rule, message, triggerTime, image } = props;
        const logger = this.getLogger(cameraDevice);

        for (const notifierId of rule.notifiers) {
            const notifier = systemManager.getDeviceById<ScryptedDevice & Notifier & DeviceBase & Settings>(notifierId);

            const { data } = await this.getNotifierData({
                device: cameraDevice,
                notifier,
                triggerTime,
                rule,
            });

            const notifierOptions: NotifierOptions = {
                body: message,
                data
            }

            const title = cameraDevice.name;

            logger.log(`Sending Audio event notification ${triggerTime} to ${notifier.name}`);
            logger.info(JSON.stringify({
                notifierOptions,
                title,
                message,
            }));

            await this.sendNotificationInternal({
                logger,
                notifier,
                title,
                icon: undefined,
                image,
                notifierOptions
            });
        }
    }

    async notifyTimelapse(props: {
        cameraDevice: DeviceInterface,
        rule: TimelapseRule,
        timelapseName: string,
    }) {
        const { cameraDevice, rule, timelapseName } = props;
        const logger = this.getLogger(cameraDevice);

        const { timelapseDownloadUrl } = await getWebookUrls({
            console: logger,
            device: cameraDevice,
            timelapseName,
            rule,
        })
        const { generatedPath } = this.getTimelapseFolder({
            ruleName: rule.name
        });

        const timelapsePath = path.join(generatedPath, timelapseName);

        const fileStats = await fs.promises.stat(timelapsePath);
        const sizeInBytes = fileStats.size;
        const fileSizeInMegabytes = sizeInBytes / (1024 * 1024);
        const isVideoValid = fileSizeInMegabytes < 50;

        for (const notifierId of (rule.notifiers ?? [])) {
            const notifier = systemManager.getDeviceById<ScryptedDevice & Notifier & DeviceBase & Settings>(notifierId);

            const { data } = await this.getNotifierData({
                device: cameraDevice,
                notifier,
                rule,
                videoUrl: timelapseDownloadUrl,
                skipVideoAttach: !isVideoValid,
                ignoreActions: true,
            });

            const message = `${rule.customText}`;

            const notifierOptions: NotifierOptions = {
                body: message,
                data
            }

            const title = cameraDevice.name;

            logger.log(`Sending Timelapse notification to ${notifier.name}`);
            logger.info(JSON.stringify({
                notifierOptions,
                title,
                message,
            }));

            await this.sendNotificationInternal({
                logger,
                notifier,
                title,
                icon: undefined,
                image: undefined,
                notifierOptions
            });
        }
    }

    async notifyNvrEvent(props: ParseNotificationMessageResult & { cameraDevice: DeviceInterface, triggerTime: number }) {
        const { eventType, textKey, triggerDevice, cameraDevice, triggerTime, label } = props;
        const logger = this.getLogger(cameraDevice);
        const rules = this.runningDetectionRules.filter(rule =>
            rule.isNvr &&
            rule.nvrEvents.includes(eventType as NvrEvent)
        );

        const { externalUrl } = this.getUrls(cameraDevice.id, triggerTime);

        const detection = eventType === NvrEvent.RecordingInterrupted ? {
            label,
        } as ObjectDetectionResult :
            undefined;

        for (const rule of rules) {
            const notifiers = rule.notifiers
            for (const notifierId of notifiers) {
                const notifier = systemManager.getDeviceById<ScryptedDevice & Notifier & DeviceBase & Settings>(notifierId);

                const message = await this.getNotificationText({
                    detection,
                    detectionTime: triggerTime,
                    notifierId,
                    textKey,
                    device: triggerDevice,
                    externalUrl,
                });

                const { data } = await this.getNotifierData({
                    device: cameraDevice,
                    notifier,
                    triggerTime,
                    rule,
                });

                const notifierOptions: NotifierOptions = {
                    body: message,
                    data
                }

                const title = cameraDevice.name;

                logger.log(`Sending Nvr event notification ${triggerTime} to ${notifier.name}`);
                logger.info(JSON.stringify({
                    notifierOptions,
                    title,
                    message,
                }));

                await this.sendNotificationInternal({
                    logger,
                    notifier,
                    title,
                    icon: undefined,
                    image: undefined,
                    notifierOptions
                });
            }
        }
    }

    async onNvrNotification(cameraName: string, options?: NotifierOptions, image?: MediaObject, icon?: MediaObject | string) {
        const logger = this.getLogger();
        const triggerTime = options?.recordedEvent?.data.timestamp ?? new Date().getTime();
        const cameraDevice = sdk.systemManager.getDeviceByName(cameraName) as unknown as DeviceInterface;
        const deviceSensors = this.videocameraDevicesMap[cameraDevice.id] ?? [];
        const { devNotifier } = this.storageSettings.values;
        const result = await parseNvrNotificationMessage(cameraDevice, deviceSensors, options, logger);
        const {
            allDetections,
            eventType,
            triggerDevice,
        } = result;

        const foundDevice = this.currentCameraMixinsMap[triggerDevice.id] || this.currentSensorMixinsMap[triggerDevice.id];
        logger.log(`NVR notification incoming ${cameraName} hasImage ${!!image} ${eventType} ${triggerDevice?.name}, device found ${!!foundDevice}`);
        logger.info(JSON.stringify(allDetections));

        if ([EventType.ObjectDetection, EventType.Package].includes(eventType as EventType)) {
            await (foundDevice as AdvancedNotifierCameraMixin)?.processDetections({
                detect: { timestamp: triggerTime, detections: allDetections },
                image,
                eventSource: ScryptedEventSource.NVR,
            });
        } else if ([EventType.Contact, EventType.Doorbell, EventType.Doorlock].includes(eventType as EventType)) {
            await (foundDevice as AdvancedNotifierSensorMixin)?.processEvent({
                triggered: true,
                triggerTime,
                image,
                eventSource: ScryptedEventSource.NVR,
            });
        } else {
            if (eventType) {
                if (!this.currentCameraMixinsMap[cameraDevice.id]?.storageSettings.values.notificationsEnabled) {
                    logger.log(`Skipping notification because disabled`);
                } else {
                    await this.notifyNvrEvent(
                        {
                            ...result,
                            cameraDevice,
                            triggerTime
                        }
                    );
                }
            } else {
                logger.log(`Notification coming from NVR not mapped yet: ${JSON.stringify({
                    cameraName,
                    options,
                    allDetections,
                    eventType,
                    triggerDevice,
                })
                    } `);
                if (devNotifier) {
                    (devNotifier as Notifier).sendNotification('Unmapped notification', {
                        body: JSON.stringify({
                            cameraName,
                            options,
                            allDetections,
                            eventType,
                            triggerDevice,
                        })
                    });
                }
            }
        }
    }

    public getLinkedCamera = async (deviceId: string) => {
        const device = systemManager.getDeviceById(deviceId) as unknown as DeviceInterface;
        const cameraDevice = await this.getCameraDevice(device);

        if (!device || !cameraDevice) {
            this.getLogger().log(`Camera device for ID ${deviceId} not found.Device found: ${!!device} and camera was found: ${!!cameraDevice} `);
        }

        return { device: cameraDevice, isDoorbell: this.doorbellDevices.includes(deviceId) };
    }

    public matchDetectionFound = async (props: {
        image?: MediaObject,
        match?: ObjectDetectionResult,
        rule: BaseRule,
        eventType: EventType,
        triggerDeviceId: string,
        detectionKey: string,
        triggerTime: number,
    }) => {
        const {
            eventType,
            triggerDeviceId,
            triggerTime,
            match,
            image,
            rule,
            detectionKey,
        } = props;
        const triggerDevice = systemManager.getDeviceById(triggerDeviceId) as unknown as DeviceInterface;
        const cameraDevice = await this.getCameraDevice(triggerDevice);
        const logger = this.getLogger(cameraDevice);

        const textKey = getTextKey({ eventType, classname: match?.className });

        if (rule.ruleType !== RuleType.Timelapse) {
            logger.log(`${rule.notifiers.length} notifiers will be notified: ${JSON.stringify({ match, rule })} `);
        }

        if (rule.ruleType === RuleType.Detection) {
            for (const notifierId of rule.notifiers) {
                const notifier = systemManager.getDeviceById(notifierId) as unknown as Settings & ScryptedDeviceBase;

                if (!this.currentCameraMixinsMap[cameraDevice.id]?.storageSettings.values.notificationsEnabled) {
                    logger.log(`Skipping notification because disabled`);
                } else {
                    this.notifyCamera({
                        triggerDevice,
                        cameraDevice,
                        notifierId,
                        time: triggerTime,
                        image,
                        detectionKey,
                        detection: match,
                        source: NotificationSource.DETECTION,
                        textKey,
                        logger,
                        rule: rule as DetectionRule,
                    }).catch(e => logger.log(`Error on notifier ${notifier.name} `, e));
                }
            }
        } else if (rule.ruleType === RuleType.Timelapse) {
            logger.debug(`Storing timelapse image for rule ${rule.name}: ${JSON.stringify({
                timestamp: triggerTime,
                id: this.id
            })
                } `);

            this.storeTimelapseFrame({
                imageMo: image,
                timestamp: triggerTime,
                device: cameraDevice,
                rule: rule as TimelapseRule
            }).catch(logger.log);
        }
    };

    async getMixin(mixinDevice: any, mixinDeviceInterfaces: ScryptedInterface[], mixinDeviceState: WritableDeviceState): Promise<any> {
        const props = {
            mixinDevice,
            mixinDeviceInterfaces,
            mixinDeviceState,
            mixinProviderNativeId: this.nativeId,
            group: 'Advanced notifier',
            groupKey: 'homeassistantMetadata',
        };

        if (
            supportedCameraInterfaces.some(int => mixinDeviceInterfaces.includes(int))
        ) {
            return new AdvancedNotifierCameraMixin(
                props,
                this
            );
        } else if (
            supportedSensorInterfaces.some(int => mixinDeviceInterfaces.includes(int))
        ) {
            return new AdvancedNotifierSensorMixin(
                props,
                this
            );
        } else if (mixinDeviceInterfaces.includes(ScryptedInterface.Notifier)) {
            return new AdvancedNotifierNotifierMixin(
                props,
                this
            );
        }
    }

    async releaseMixin(id: string, mixinDevice: any): Promise<void> {
        await mixinDevice.release();
    }

    private getUrls(cameraId: string, time: number) {
        const serverId = this.storageSettings.getItem('serverId');
        const nvrUrl = this.storageSettings.getItem('nvrUrl');
        const scryptedToken = this.storageSettings.getItem('scryptedToken');

        const timelinePart = `#/timeline/${cameraId}?time=${time}&from=notification&serverId=${serverId}&disableTransition=true`;
        const haUrl = `/api/scrypted/${scryptedToken}/endpoint/@scrypted/nvr/public/${timelinePart} `
        const externalUrl = `${nvrUrl}/${timelinePart}`
        return { externalUrl: externalUrl, haUrl: `/scrypted_${scryptedToken}?url=${encodeURIComponent(haUrl)}` }
    }

    private getTriggerZone = (detection: ObjectDetectionResult, rule: DetectionRule) => {
        const { zones } = detection ?? {};
        let zone: string;
        if (rule?.whitelistedZones) {
            zone = detection?.zones?.find(zoneInner => rule.whitelistedZones.includes(zoneInner));
        } else {
            zone = zones?.[0];
        }

        return zone;
    }

    private async getNotificationText(
        props: {
            device: DeviceInterface,
            detectionTime: number,
            detection?: ObjectDetectionResult,
            notifierId: string,
            externalUrl?: string,
            textKey: string,
            rule?: DetectionRule,
        }
    ) {
        const { detection, detectionTime, notifierId, device, externalUrl, textKey, rule } = props;
        const { label, className } = detection ?? {};

        const roomName = this.deviceRoomMap[device.id];

        const textToUse = rule?.customText || this.currentNotifierMixinsMap[notifierId]?.storageSettings.values[textKey] || this.storageSettings.getItem(textKey as any);

        const classNameParsed = detectionClassesDefaultMap[className];
        const detectionTimeText = this.storageSettings.getItem(`notifier:${notifierId}:detectionTimeText` as any) || this.storageSettings.getItem('detectionTimeText');
        const detectionClassText = classNameParsed === DetectionClass.Person ? this.storageSettings.getItem('personText') :
            className === DetectionClass.Animal ? this.storageSettings.getItem('animalText') :
                className === DetectionClass.Vehicle ? this.storageSettings.getItem('vehicleText') :
                    className
        const time = eval(detectionTimeText.replace('${time}', detectionTime));

        const zone = this.getTriggerZone(detection, rule);

        return textToUse.toString()
            .replace('${time}', time)
            .replace('${nvrLink}', externalUrl ?? '')
            .replace('${person}', label ?? '')
            .replace('${plate}', label ?? '')
            .replace('${streamName}', label ?? '')
            .replace('${label}', label ?? '')
            .replace('${class}', detectionClassText ?? '')
            .replace('${zone}', zone ?? '')
            .replace('${room}', roomName ?? '');
    }

    async getNotifierData(props: {
        notifier: DeviceBase,
        rule?: DetectionRule | OccupancyRule | TimelapseRule,
        detectionKey?: string,
        device: ScryptedDeviceBase,
        triggerTime?: number,
        ignoreActions?: boolean,
        skipVideoAttach?: boolean,
        videoUrl?: string
    }) {
        const { notifier, rule, triggerTime, device, videoUrl, ignoreActions, skipVideoAttach, detectionKey } = props;
        const { priority, actions } = rule ?? {};

        const { haUrl, externalUrl } = this.getUrls(device.id, triggerTime);
        const deviceLogger = this.getLogger(device);

        const haActions = this.currentCameraMixinsMap[device.id].storageSettings.values.haActions ?? [];

        if (actions) {
            haActions.push(...actions);
        }
        const haActionsToNotify: any[] = [];
        let snoozeActions: SnoozeAction[] = [];

        try {
            haActions.forEach(haAction => haActionsToNotify.push(JSON.parse(haAction)));
        } catch (e) {
            this.getLogger().log(`Error building ha actions: ${JSON.stringify({ haActions, actions })}.`, e);
        }

        const mixin = this.currentNotifierMixinsMap[notifier.id];
        if (rule.ruleType === RuleType.Detection && mixin.storageSettings.values.addSnoozeActions) {
            const snoozes = [5, 15, 60];
            const { snoozeUrls } = await getWebookUrls({
                console: deviceLogger,
                device,
                snoozes,
                detectionKey
            });
            snoozeActions = snoozeUrls;
            snoozeUrls.forEach(({ text, url }) => {
                haActionsToNotify.push({
                    title: text,
                    action: 'call_webhook',
                    uri: url,
                })
            });
        }

        let data: any = {};

        if (notifier.pluginId === PUSHOVER_PLUGIN_ID) {
            data.pushover = {
                timestamp: triggerTime,
                url: !videoUrl ? externalUrl : videoUrl,
                html: 1,
                priority: getPushoverPriority(priority)
            };
        } else if (notifier.pluginId === HOMEASSISTANT_PLUGIN_ID) {
            data.ha = {
                url: videoUrl ?? haUrl,
                clickAction: videoUrl ?? haUrl,
                video: !skipVideoAttach ? videoUrl : undefined,
                actions: !ignoreActions ? [...haActionsToNotify, ...snoozeActions] : undefined
            }
        }

        return { data, snoozeActions };
    }

    async notifyCamera(props: NotifyCameraProps) {
        try {
            const {
                triggerDevice,
                cameraDevice,
                notifierId,
                time,
                image: imageParent,
                detection,
                textKey,
                source,
                logger,
                rule,
                skipImage,
                detectionKey,
            } = props;

            const device = cameraDevice ?? await this.getCameraDevice(triggerDevice);

            if (!device) {
                logger.log(`There is no camera linked to the device ${triggerDevice.name}`);
                return;
            }

            const notifier = systemManager.getDeviceById<Notifier & ScryptedDevice & DeviceBase>(notifierId);

            const { externalUrl } = this.getUrls(device.id, time);

            let message = await this.getNotificationText({
                detection,
                externalUrl,
                detectionTime: time,
                notifierId,
                textKey,
                device: triggerDevice,
                rule,
            });

            const { image, b64Image } = !skipImage ? await this.getCameraSnapshot({
                cameraDevice: device,
                image: imageParent,
            }) : {};


            let title = (triggerDevice ?? device).name;

            const zone = this.getTriggerZone(detection, rule);
            if (zone) {
                title += ` (${zone})`;
            }

            const aiPlatform = this.storageSettings.getItem('aiPlatform') as AiPlatform;
            if (aiPlatform !== AiPlatform.Disabled && rule.useAi) {
                const imageUrl = `data:image/jpeg;base64,${b64Image}`;
                const aiResponse = await getAiMessage({
                    imageUrl,
                    b64Image,
                    logger,
                    originalTitle: message,
                    plugin: this,
                    detection,
                });

                message = aiResponse.message ?? message;
                title = aiResponse.title ?? title;
            }

            const { data, snoozeActions } = await this.getNotifierData({
                device,
                notifier,
                rule,
                triggerTime: time,
                detectionKey,
            });

            if (notifier.id === PUSHOVER_PLUGIN_ID) {
                message += '\n';
                for (const { text, url } of snoozeActions) {
                    message += `<a href="${url}">${text}</a>\n`;
                }
            }

            const notifierOptions: NotifierOptions = {
                body: message,
                data
            }

            logger.log(`Sending detection notification ${time} to ${notifier.name}`);
            logger.info(JSON.stringify({
                notifierOptions,
                source,
                title,
                message,
                rule,
                detection,
            }));

            await this.sendNotificationInternal({
                logger,
                notifier,
                title,
                icon: undefined,
                image,
                notifierOptions,
                source
            });
        } catch (e) {
            this.getLogger().log('Error in notifyCamera', e);
        }
    }

    async sendNotificationInternal(props: {
        logger: Console,
        title: string,
        notifierOptions?: NotifierOptions,
        image?: MediaObject | string,
        icon?: MediaObject | string,
        source?: NotificationSource,
        notifier: ScryptedDevice & Notifier & DeviceBase
    }) {
        const { title, icon, image, notifierOptions, logger, notifier, source } = props;
        const isEnabled = this.currentNotifierMixinsMap[notifier.id]?.storageSettings.values.enabled ?? true;

        if (!isEnabled) {
            logger.log(`Notifier ${notifier.name} skipped because disabled`);
        } else {
            await notifier.sendNotification(title, notifierOptions, image, icon);
        }
    }


    async executeNotificationTest() {
        const testDevice = this.storageSettings.getItem('testDevice') as DeviceInterface;
        const testNotifier = this.storageSettings.getItem('testNotifier') as DeviceInterface;
        const textKey = this.storageSettings.getItem('testMessage') as string;
        const testPriority = this.storageSettings.getItem('testPriority') as NotificationPriority;
        const testUseAi = this.storageSettings.getItem('testUseAi') as boolean;

        const logger = this.getLogger(testDevice);

        try {
            if (testDevice && textKey && testNotifier) {
                const currentTime = new Date().getTime();
                const testNotifierId = testNotifier.id

                logger.log(`Sending test notification to ${testNotifier.name} - ${testDevice.name} with key ${textKey}}`);

                this.notifyCamera({
                    triggerDevice: testDevice,
                    notifierId: testNotifierId,
                    time: currentTime,
                    textKey,
                    detection: { label: 'Familiar' } as ObjectDetectionResult,
                    source: NotificationSource.TEST,
                    logger,
                    detectionKey: 'testIdentifierKey',
                    rule: { priority: testPriority, useAi: testUseAi } as DetectionRule
                })
            }
        } catch (e) {
            logger.log('Error in executeNotificationTest', e);
        }
    }

    async getCameraDevice(device: DeviceInterface) {
        const deviceType = device.type;
        const deviceId = device.id;
        const isCamera = [ScryptedDeviceType.Camera, ScryptedDeviceType.Doorbell].includes(deviceType);

        if (isCamera) {
            return device;
        }

        const linkedCameraId = this.deviceVideocameraMap[deviceId];
        return systemManager.getDeviceById(linkedCameraId) as unknown as DeviceInterface;
    }

    private async getCameraSnapshot(props: {
        cameraDevice: DeviceInterface,
        image?: MediaObject,
    }) {
        const { cameraDevice, image: imageParent } = props;

        let image = imageParent;

        if (!image) {
            try {
                image = await cameraDevice.takePicture({
                    reason: 'event',
                    picture: {
                        width: SNAPSHOT_WIDTH,
                    },
                });
            } catch (e) {
                this.getLogger().log('Error taking a picture in plugin', e);
            }
        }

        let imageBuffer = await sdk.mediaManager.convertMediaObjectToBuffer(image, 'image/jpeg');

        const b64Image = imageBuffer.toString('base64');

        return { image, b64Image };
    }

    public getImagePath = (props: { imageIdentifier: string, device: ScryptedDeviceBase }) => {
        const { device, imageIdentifier } = props;
        const { imagesPath } = this.storageSettings.values;
        const savePath = path.join(imagesPath, device.name);
        const filePath = path.join(savePath, `${imageIdentifier}.jpg`);

        return { savePath, filePath };
    }

    public storeImage: StoreImageFn = async (props) => {
        const { device, name, timestamp, b64Image, classname, label } = props;
        const { imagesPath, imagesRegex } = this.storageSettings.values;
        const logger = this.getLogger(device);

        if (imagesPath && b64Image) {
            const { savePath } = this.getImagePath({ device, imageIdentifier: name });

            try {
                await fs.promises.access(savePath);
            } catch {
                await fs.promises.mkdir(savePath, { recursive: true });
            }

            const filename = imagesRegex
                .replace('${name}', name)
                .replace('${timestamp}', timestamp);

            const latestImage = `${name}${LATEST_IMAGE_SUFFIX}`;
            const { filePath: imagePath } = this.getImagePath({ device, imageIdentifier: filename });
            const { filePath: latestPath } = this.getImagePath({ device, imageIdentifier: latestImage });

            const base64Data = b64Image.replace(/^data:image\/png;base64,/, "");
            await fs.promises.writeFile(imagePath, base64Data, 'base64');
            await fs.promises.writeFile(latestPath, base64Data, 'base64');

            const mixin = this.currentCameraMixinsMap[device.id];
            const {
                postDetectionImageUrls,
                postDetectionImageClasses,
                postDetectionImageWebhook
            } = mixin.storageSettings.values;

            if (
                postDetectionImageWebhook &&
                postDetectionImageClasses?.includes(classname) &&
                mixin.isDelayPassed({
                    type: 'PostWebhookImage',
                    classname,
                })
            ) {
                for (const url of postDetectionImageUrls) {
                    logger.log(`Posting ${classname} image to ${url}, ${timestamp} ${label}`);
                    await axios.post(url, {
                        classname,
                        label,
                        b64Image,
                        timestamp,
                        name
                    }, { timeout: 5000 }).catch(e => {
                        logger.log(`Error webhook POST ${url}: ${e.message}`);
                    });
                }
            }
        }
    }

    public getTimelapseFolder = (props: {
        ruleName: string,
    }) => {
        let { imagesPath } = this.storageSettings.values;
        if (!imagesPath) {
            imagesPath = process.env.SCRYPTED_PLUGIN_VOLUME;
        }

        const { ruleName } = props;
        const mainTimelapsePath = path.join(imagesPath, 'timelapses');
        const timelapsePath = path.join(mainTimelapsePath, ruleName);
        const framesPath = path.join(timelapsePath, 'frames');
        const generatedPath = path.join(timelapsePath, 'generated');

        return {
            mainTimelapsePath,
            timelapsePath,
            framesPath,
            generatedPath,
        };
    }

    public storeTimelapseFrame = async (props: {
        rule: TimelapseRule,
        timestamp: number,
        device: ScryptedDeviceBase,
        imageMo: MediaObject
    }) => {
        const { rule, timestamp, imageMo: imageMoParent, device } = props;
        const { imagesPath } = this.storageSettings.values;

        let imageMo = imageMoParent;

        if (!imageMo) {
            imageMo = (await (this.currentCameraMixinsMap[device.id])?.getImage({ preferLatest: true }))?.image;
        }

        if (imagesPath && imageMo) {
            const { framesPath } = this.getTimelapseFolder({ ruleName: rule.name });

            try {
                await fs.promises.access(framesPath);
            } catch {
                await fs.promises.mkdir(framesPath, { recursive: true });
            }

            const jpeg = await mediaManager.convertMediaObjectToBuffer(imageMo, 'image/jpeg');
            await fs.promises.writeFile(path.join(framesPath, `${timestamp}.jpg`), jpeg);
        }
    }

    public timelapseRuleStarted = async (props: {
        rule: TimelapseRule,
        logger: Console,
        device: ScryptedDeviceBase,
    }) => {
        const { device, rule, logger } = props;
        try {
            logger.log(`Clearing frames for rule ${rule.name}.`);
            this.clearFramesData({
                device,
                logger,
                rule,
            }).catch(logger.error);
        } catch (e) {
            logger.error(`Error starting timelapse rule ${rule.name}`, e);
        }
    }

    public clearFramesData = async (props: {
        rule: TimelapseRule,
        device: ScryptedDeviceBase,
        logger: Console
    }) => {
        const { rule, logger } = props;
        const { framesPath } = this.getTimelapseFolder({ ruleName: rule.name });

        await fs.promises.rm(framesPath, { recursive: true, force: true, maxRetries: 10 });
        logger.log(`Folder ${framesPath} removed`);
    }

    public timelapseRuleEnded = async (props: {
        rule: TimelapseRule,
        device: ScryptedDeviceBase,
        logger: Console,
    }) => {
        const { device, rule, logger } = props;
        const { imagesPath } = this.storageSettings.values;

        if (imagesPath) {
            try {
                const { timelapsePath, framesPath, generatedPath } = this.getTimelapseFolder({ ruleName: rule.name });
                const listPath = path.join(timelapsePath, 'file_list.txt');

                const timelapseName = `${getNowFriendlyDate()}.mp4`;
                const outputFile = path.join(generatedPath, timelapseName);

                const files = await fs.promises.readdir(framesPath);
                const sortedFiles = files
                    .sort((a, b) => parseInt(a) - parseInt(b));
                const fileListContent = sortedFiles
                    .map(file => `file '${path.join(framesPath, file)}'`)
                    .join('\n');
                await fs.promises.writeFile(listPath, fileListContent);

                try {
                    await fs.promises.access(generatedPath);
                } catch {
                    await fs.promises.mkdir(generatedPath, { recursive: true });
                }

                const ffmpegArgs = [
                    '-loglevel', 'error',
                    '-f', 'concat',
                    '-safe', '0',
                    '-r', `${rule.timelapseFramerate}`,
                    '-i', listPath,
                    '-vf', 'pad=ceil(iw/2)*2:ceil(ih/2)*2',
                    '-c:v', 'libx264',
                    '-pix_fmt', 'yuv420p',
                    '-y',
                    outputFile
                ];

                logger.log(`Generating timelapse ${rule.name} with arguments: ${ffmpegArgs}`);

                const cp = child_process.spawn(await sdk.mediaManager.getFFmpegPath(), ffmpegArgs, {
                    stdio: 'inherit',
                });
                await once(cp, 'exit');

                if (!this.currentCameraMixinsMap[device.id]?.storageSettings.values.notificationsEnabled) {
                    logger.log(`Skipping notification because disabled`);
                } else {
                    await this.notifyTimelapse({
                        cameraDevice: device as DeviceInterface,
                        timelapseName,
                        rule
                    });
                }
            } catch (e) {
                logger.log('Error generating timelapse', e);
            }
        }
    }
}

